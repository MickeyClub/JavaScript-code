<!DOCTYPE html>
<html>
<head lang="en">
  <meta charset="UTF-8">
  <title>标题</title>
  <script>
    //1.函数执行的三种方式. 主要的是搞清楚函数中的this是谁.
    //a.作为函数执行.
    //this就是window.
    function test1(){
      console.log("哈哈,我是test1");
      console.log(this);
    }
    // test1(); //这里相当于是window.test1();


    //b.作为方法执行.
    //谁调用这个方法,那这个方法中的this就是谁.
    var name = '我是window的name';
    var obj = {
      name:'杨康',
      sayHi: function () {
        console.log("哈哈哈,我是"+this.name);
      }
    };
    //obj.sayHi();


    //c.这句话的意思是,给test1重新赋值,赋obj.sayHi这个函数.
    //不要管函数是如何声明的,要看函数是如何调用的.
    // test1 = obj.sayHi;
    // test1();//这里相当于是window.test1();


    //d.这句话的意思是给obj.sayHi重新赋值,赋test1的函数体.
    // obj.sayHi = test1;
    // obj.sayHi();//这里是obj在调用函数,所以函数里面的this是obj.



    //e.作为构造函数执行
    //构造函数配合new关键字使用,构造函数中的this就是new关键字创建出来的对象.
    function Dog(name){
      this.name = name;
      console.log(this);
    }
    //var d1 =  new Dog('来福');


    //构造函数当做普通函数来调用.
    //this就是window
    //Dog('旺财');//这里就相当于window.Dog();




    //结论:
    //不管函数是如何声明的,不管声明在哪儿,也不管声明成什么样,都不管,只需要管他是如何调用的, 谁调用这个函数,这个函数中的this就是谁.




    //补充: 计时器里面的回调函数.里面的this是window.

    // setTimeout(function () {
    //   console.log(this);
    // },1000);

    // setInterval(function () {
    //   console.log(this);
    // },1000);


    // var obj = {
    //   name:'石鹏',
    //   sayHi: function () {
    //     console.log('你好,我是石鹏...');
    //     console.log(this); //window
    //   }
    // };
    // setInterval(obj.sayHi,1000); //这里只是拿到obj对象里面的sayHi函数而已, 这个函数等待1秒还是window调用的.







    //-------------------------------------------------
    //函数和方法,都是一段代码封装起来的.
    //函数没有归属感
    //方法是属于对象的,有归属感.
  </script>
</head>
<body>

</body>
</html>